#version 460 core

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

#define NUM_BOID_TYPES 12

struct Boid {
    // todo: recalculate bytes
    vec4 pos;                             // 4 * 4      # 16
    vec4 velocity;                        // 4 * 4      # 32
    vec4 lastVelocity;                    // 4 * 4      # 48
    vec4 dir;                             // 4 * 4      # 64
    vec4 scale;                           // 4 * 4      # 80
    vec4 currentHome;                     // 4 * 4      # 96
    vec2 bounds;                          // 2 * 4      # 104
    float min_speed;                      // 4          # 108
    float max_speed;                      // 4          # 112
    float minSepDistance;                 // 4          # 116
    float matchingFactor;                 // 4          # 120
    float centeringFactor;                // 4          # 124
    float avoidFactor;                    // 4          # 128
    float minEnemyInterceptDistance;      // 4          # 132
    float minEnemyChaseDistance;          // 4          # 136
    float fearWeight;                     // 4          # 140
    float goalWeight;                     // 4          # 144
    int canHaveHome;                      // 4          # 192
    int hasHome;                          // 4          # 240
    int isBeingChased;                    // 4          # 244
    int isChasing;                        // 4          # 248
    float boidsAround;                    // 4          # 252
    uint type;                            // 4          # 256
    uint ID;                              // 4          # 260
    uint myPredators[NUM_BOID_TYPES];     // 4 * 12     # 308
    uint myPrey[NUM_BOID_TYPES];          // 4 * 12     # 320
};

uint F_THREADFIN = 0;
uint F_MARLIN = 1;
uint F_SPEAR_FISH = 2;
uint F_TUNA = 3;
uint F_HERRING = 4;
uint F_CLOWNFISH = 5;
uint S_BLUE = 6;
uint S_WHALE = 7;
uint S_WHITE = 8;
uint WHALE = 9;
uint DOLPHIN = 10;
uint PLANKTON = 11;

float sq(float s) { return s * s; }
float sq(int s) { return s * s; }
mat4 getTranslationMat(vec3 pos);
mat4 getScaleMat(vec3 scale);
float sqDist(vec4 a, vec4 b);
bool isFamily(uint idxa, uint idxb);
bool isPredatorTo(uint idxa, uint idxb);
bool isPreyTo(uint idxa, uint idxb);
bool isNeutral(uint idxa, uint idxb);
float getFearWeight(uint idxa, uint idxb);
void limitSpeed(uint idx);
mat4 getLookAtMat(uint idx);
void constrainBounds(uint idx);
void move(uint idx);
void update(uint idx);
void process(uint idx);
bool checkNan(vec3 v);
bool checkNan(vec4 v);
void resetVelocity(uint bidx);
void checkAndResetVelocity(uint bidx);

layout(std430, binding = 3) buffer BoidStructs {
    Boid boids[];
};

layout(std430, binding = 4) buffer readonly HomeLocs {
    vec4 homes[];
};

layout(std430, binding = 5) buffer BIndices {
    uint indices[];
};

layout(std430, binding = 6) buffer writeonly TransOut {
    mat4 transforms[];
};

uniform float deltaTime;
uniform bool canAttack;
uniform vec3 gridSize;
uniform int idBase;
// uniform vec3 playerPos;

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint rid = idBase + gid;
    if (rid >= boids.length()) return;
    process(rid);
    transforms[rid] = getLookAtMat(rid) * getScaleMat(boids[rid].scale.xyz);
}

// Create a lookAt matrix from a position, direction, and up vector. Taken from GLM
mat4 getLookAtMat(uint idx) {
    vec3 up = vec3(0, 1, 0);
    vec3 from = boids[idx].pos.xyz;
    vec3 to = normalize(boids[idx].velocity.xyz);

    vec3 f = normalize((from + to) - from);
    vec3 s = normalize(cross(f, up));
    vec3 u = cross(s, f);

    mat4 m = mat4(1);
    m[0][0] = s.x;
    m[1][0] = s.y;
    m[2][0] = s.z;
    m[0][1] = u.x;
    m[1][1] = u.y;
    m[2][1] = u.z;
    m[0][2] =-f.x;
    m[1][2] =-f.y;
    m[2][2] =-f.z;
    m[3][0] =-dot(s, from);
    m[3][1] =-dot(u, from);
    m[3][2] = dot(f, from);
    
    mat4 mat = getTranslationMat(from);
    return mat * inverse(m);
}

void move(uint idx) {
    int numNeighbors = 0;
    int numFamily = 0; // only move by family rules if near family. otherwise, boid will move towards origin due to subtraction in alignment and cohesion checks
    int numStrangers = 0;

    // alignment variable
    vec4 avgVel = vec4(0);
    vec4 avgStrangerVel = vec4(0);

    // cohesion
    vec4 avgCentre = vec4(0);
    vec4 avgStrangerCentre = vec4(0);

    // separation variables
    vec4 avgMove = vec4(0);
    vec4 avgStrangerMove = vec4(0);
    // if being chased, ignore all prey. define separate attacking and fleeing so that any behaviour defined
    // before fully seen (i.e., deciding to chase before finding a predator in boid list) can be undone
    vec4 avgMoveAtt = vec4(0);
    vec4 avgMoveFlee = vec4(0);

    bool isBeingChased = false;    // am i being chased?
    bool isInPursuit = false;      // am i chasing prey (intercepting or chasing)
    bool isInChasing = false;      // am i chasing prey (chasing only)
    vec4 closestPrey = vec4(1e9);  // chase closest prey instead of group if it's within chase distance
    float closestPreyDist = 1e9;
    float closestPreyDisttmp = 1e9;
    float biggestFearWeight = 0;
    float strangerFactor = 0.001;

    float visibleRange = 4;
    // if (boids[idx].type >= S_BLUE && boids[idx].type <= DOLPHIN) visibleRange = 180;
    float homeRange = 40;
    float newHomeDistDrift = 20; // distance to determine new home when drifting (i.e., not fleeing or chasing)
    float newHomeDistFlee = 10; // distance to determine new home when fleeing

    for (int i = 0; i < boids.length(); ++i) {
        // uint odx = (idx + i) % boids.length();
        uint odx = i;
        if (boids[odx].ID == boids[idx].ID) continue;
        float tDist = sqDist(boids[idx].pos, boids[odx].pos);
        if (tDist < sq(visibleRange)) {
            float distFromBoid = sqrt(tDist);
            numNeighbors++;
            // stay within group of same boid type
            if (isFamily(idx, odx)) {
                numFamily++;

                // alignment
                avgVel += boids[odx].velocity;

                // cohesion
                avgCentre += boids[odx].pos;

                // separation
                if (tDist < sq(boids[idx].minSepDistance)) {
                    avgMove += boids[idx].pos - boids[odx].pos;
                }
            } else if (isNeutral(idx, odx)) {
                numStrangers++;

                // alignment
                avgStrangerVel += boids[odx].velocity;

                // cohesion
                avgStrangerCentre += boids[odx].pos;

                // separation
                if (tDist < sq(boids[idx].minSepDistance)) {
                    avgStrangerMove += boids[idx].pos - boids[odx].pos;
                }
            } else if (!canAttack) {
                // to avoid altering if-statement structure in case i decide to remove this
                // todo: add slight flocking behaviour to non-enemmies
                continue;
            } else {
                if (isPreyTo(idx, odx)) {
                    if (tDist <= sq(boids[idx].minEnemyInterceptDistance)) {
                        isBeingChased = true;
                    }
                    biggestFearWeight = max(biggestFearWeight, getFearWeight(idx, odx));
                    avgMoveFlee += (boids[idx].pos - boids[odx].pos) * biggestFearWeight;
                } else if (isPredatorTo(idx, odx)) {
                    isInPursuit = isInPursuit || tDist <= sq(boids[idx].minEnemyInterceptDistance);
                    if (tDist <= sq(boids[idx].minEnemyChaseDistance)) {
                        // move towards goal
                        isInChasing = true;
                        if (tDist < sq(closestPreyDist)) {
                            closestPrey = boids[odx].pos;
                            closestPreyDist = tDist;
                        }
                        avgMoveAtt -= (boids[idx].pos - boids[odx].pos) * boids[idx].goalWeight;
                    } else if (tDist <= sq(boids[idx].minEnemyInterceptDistance)) {
                        // intercept goal
                        // doing it like this means predators are drawn towards larger groups more than single prey
                        avgMoveAtt -= (boids[idx].pos - (boids[odx].pos + boids[odx].velocity)) * boids[idx].goalWeight;
                    }
                }
            }
        }
    }

    boids[idx].isBeingChased = int(isBeingChased);
    boids[idx].isChasing = int(isInPursuit);

    // Determine where the home is
    if (boids[idx].canHaveHome == 1) {
        if (sqDist(boids[idx].pos, boids[idx].currentHome) > homeRange * homeRange) {
            boids[idx].hasHome = 0;
            float consideredHomeDist = isBeingChased ? sq(newHomeDistFlee) : sq(newHomeDistDrift);
            for (int i = 0; i < homes.length(); ++i) {
                if (sqDist(boids[idx].pos, homes[i]) < consideredHomeDist) {
                    boids[idx].currentHome = homes[i];
                    boids[idx].hasHome = 1;
                    break;
                }
            }
        }
    }

    boids[idx].boidsAround = int(isInPursuit);
    if (numNeighbors != 0) {
        if (numFamily != 0) {
            // alignment
            avgVel /= numFamily;
            boids[idx].velocity += (avgVel - boids[idx].velocity) * boids[idx].matchingFactor;

            // cohesion
            avgCentre /= numFamily;
            boids[idx].velocity += (avgCentre - boids[idx].pos) * boids[idx].centeringFactor;
        }
        if (numStrangers != 0) {
            // alignment
            avgStrangerVel /= numStrangers;
            boids[idx].velocity += (avgStrangerVel - boids[idx].velocity) * boids[idx].matchingFactor * strangerFactor;

            // cohesion
            avgStrangerCentre /= numStrangers;
            boids[idx].velocity += (avgStrangerCentre - boids[idx].pos) * boids[idx].centeringFactor * strangerFactor;
        }

        // separation
        if (isBeingChased) {
            if (boids[idx].hasHome == 1) {
                avgMoveFlee -= (boids[idx].pos - boids[idx].currentHome) * biggestFearWeight * 0.000005;  // fleeing home
            }
            boids[idx].velocity += avgMoveFlee * boids[idx].avoidFactor;
        } else if (isInPursuit) {
            if (isInChasing) {
                // chase closest target only
                avgMoveAtt = -(boids[idx].pos - closestPrey) * boids[idx].goalWeight;
            }
            boids[idx].velocity += avgMoveAtt * boids[idx].avoidFactor;
        }
        if (boids[idx].hasHome == 1) {
            boids[idx].velocity -= (boids[idx].pos - boids[idx].currentHome) * 0.0005; // drift towards home
        } else {
            boids[idx].velocity -= (boids[idx].pos - vec4(0)) * 0.000005; // drift towards centre
        }
        boids[idx].velocity += avgMove * boids[idx].avoidFactor;
        boids[idx].velocity += avgStrangerMove * boids[idx].avoidFactor * strangerFactor;
    }
}

void limitSpeed(uint idx) {
    float tspeed = dot(boids[idx].velocity, boids[idx].velocity);
    if ((tspeed < boids[idx].min_speed * boids[idx].min_speed)) {
        boids[idx].velocity *= 1.1;
        boids[idx].dir = normalize(boids[idx].velocity);
    } else {
        float max_speed = boids[idx].max_speed;
        if (tspeed > boids[idx].max_speed * boids[idx].max_speed) {
            boids[idx].velocity = normalize(boids[idx].velocity) * boids[idx].max_speed;
        }
    }
    checkAndResetVelocity(idx);
}

void constrainBounds(uint idx) {
    float tf = .2;
    if (boids[idx].pos.x < -gridSize.x)
        boids[idx].velocity.x += tf;
    if (boids[idx].pos.x > gridSize.x)
        boids[idx].velocity.x -= tf;
    if (boids[idx].pos.y < boids[idx].bounds.x)
        boids[idx].velocity.y += tf;
    if (boids[idx].pos.y > boids[idx].bounds.y)
        boids[idx].velocity.y -= tf;
    if (boids[idx].pos.z < -gridSize.z)
        boids[idx].velocity.z += tf;
    if (boids[idx].pos.z > gridSize.z)
        boids[idx].velocity.z -= tf;
}

void update(uint idx) {
    checkAndResetVelocity(idx);
    boids[idx].lastVelocity = mix(boids[idx].lastVelocity, boids[idx].velocity, deltaTime * 8);
    boids[idx].pos += boids[idx].lastVelocity * deltaTime;
}

void process(uint idx) {
    boids[idx].dir = normalize(boids[idx].velocity);
    constrainBounds(idx);
    move(idx);
    limitSpeed(idx);
    update(idx);
}

bool isFamily(uint idxa, uint idxb) {
    return boids[idxa].type == boids[idxb].type;
}

bool isNeutral(uint idxa, uint idxb) {
    return !isPredatorTo(idxa, idxb) && !isPreyTo(idxa, idxb);
}

bool isPredatorTo(uint idxa, uint idxb) {
    return boids[idxa].myPrey[boids[idxb].type] == 1;
}

bool isPreyTo(uint idxa, uint idxb) {
    return boids[idxa].myPredators[boids[idxb].type] == 1;
}

float getFearWeight(uint idxa, uint idxb) {
    if (isPreyTo(idxa, idxb)) {
        return 5;
    } else if (isPredatorTo(idxa, idxb) || isFamily(idxa, idxb)) {
        return 0;
    } else {
        return max(((boids[idxb].scale / boids[idxa].scale) - boids[idxa].scale).x, 0.0f);
    }
}

// Compute the squared distance between `a` and `b`. Use `glm::distance` for actual distance
float sqDist(vec4 a, vec4 b) {
    vec4 diff = a - b;
    return dot(diff, diff);
}

mat4 getTranslationMat(vec3 pos) {
    mat4 m = mat4(1);
    m[3][0] = pos.x;
    m[3][1] = pos.y;
    m[3][2] = pos.z;
    return m;
}

mat4 getScaleMat(vec3 scale) {
    mat4 m = mat4(1);
    m[0] *= scale[0];
    m[1] *= scale[1];
    m[2] *= scale[2];
    return m;
}

// uint flatten3(vec3 v) {
//     return v.x + v.y * gridSize.x + v.z * gridSize.x * gridSize.y;
// }

bool checkNan(vec3 v) {
    return any(isnan(v));
}
bool checkNan(vec4 v) {
    return any(isnan(v));
}
void checkAndResetVelocity(uint idx) {
    if (checkNan(boids[idx].velocity)) {
        resetVelocity(idx);
    }
}
void resetVelocity(uint idx) {
    boids[idx].velocity = vec4(boids[idx].min_speed);
    boids[idx].dir = normalize(boids[idx].velocity);
}
