#version 460 core

layout (local_size_x = 2) in;

// the maximum amount of keyframes allowed. 
// requires that skinned meshes be exported without sampling or that animation has less than 32 frames total
#define MAX_KEYFRAMES 32
#define MAX_JOINTS 16

// 64 + 64 + 512 + 512 + 512 + 128 + 16 = 1808 bytes
struct Animation {
    int boneIndex;                           // index of bone this animation applies to                              # 4
    float animDuration;                      // length of the animation in ticks                                     # 4
    mat4 relTransformation;                  // transformation relative to parent (aiNode->mTransformation)          # 4 * 4 * 4 = 64
    mat4 globalInvTransform;                 // global inverse transform of root node of mesh's skeleton             # 4 * 4 * 4 = 64
    vec4 positionKeys[MAX_KEYFRAMES];        // changes in position (first 3) and time of keys (last float)          # 4 * 4 * 32 = 512
    vec4 scalingKeys[MAX_KEYFRAMES];         // changes in scaling (first 3) and time of keys (last float)           # 4 * 4 * 32 = 512
    vec4 rotationKeys[MAX_KEYFRAMES];        // changes in rotation                                                  # 4 * 4 * 32 = 512
    float rotationKeysTimes[MAX_KEYFRAMES];  // times of rotation keys                                               # 4 * 32 = 128
    vec2 an_padding;                         // padding                                                              # 4 * 2 = 8
};

// 64 + 64 + 4 + 64 + 8 = 204 bytes
struct BoneInfo {
    mat4 offsetMatrix;                       // inverse bind matrix for the bone                                     # 4 * 4 * 4 = 64
    mat4 currentTransformation;              // current transformation of the bone                                   # 4 * 4 * 4 = 64
    int ID;                                  // bone id                                                              # 4
    int children[MAX_JOINTS];                // ids of children bones                                                # 4 * 16 = 64
    vec2 bi_padding;                         // padding                                                              # 4 * 2 = 8
};

layout (std430, binding = 0) buffer Animations {
    Animation animations[];
};

layout (std430, binding = 1) buffer BoneInfos {
    BoneInfo infos[];
};

layout (std430, binding = 2) buffer AnimationLengths {
    int aLength[];
};

layout (std430, binding = 3) buffer bufferOffsets {
    int offsets[];
};

// interpolate quaternions
// copied from assimp's implementation, which itself was adopted from gmtl
vec4 slerp(vec4 q1, vec4 q2, float t) {
    float epsilon = 0.00001; // min float distance to be considered equal

    float cos_omega = 
        q1.x * q2.x + 
        q1.y * q2.y + 
        q1.z * q2.z + 
        q1.w * q2.w;
    
    vec4 end = q2;
    // reverse signs if quaternion is negative
    if (cos_omega < 0.0) {
        cos_omega = -cos_omega;
        end.x = -end.x;
        end.y = -end.y;
        end.z = -end.z;
        end.w = -end.w;
    }

    float factor_start = 0;
    float factor_end = 0;
    if (1 - cos_omega > epsilon) {
        float omega = acos(cos_omega);
        float sin_omega = sin(omega);
        factor_start = sin(omega * (1 - t)) / sin_omega;
        factor_end = sin(t * omega) / sin_omega;
    } else {
        // do linear interpolation if near the end of the animation
        factor_start = 1 - t;
        factor_end = t;
    }

    vec4 outq = vec4(
        factor_start * q1.x + factor_end * end.x,
        factor_start * q1.y + factor_end * end.y,
        factor_start * q1.z + factor_end * end.z,
        factor_start * q1.w + factor_end * end.w
    );
    return outq;
}

// quaternion to mat3
// taken from assimp's implementation but transposed since assimp uses a row-major format
mat3 quatToMat(vec4 q) {
    mat3 m;
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    m[0][0] = 1 - 2 * (y*y + z*z);
    m[0][1] = 2 * (x*y + z*w);
    m[0][2] = 2 * (x*z - w*y);
    m[1][0] = 2 * (x*y - z*w);
    m[1][1] = 1 - 2 * (x*x + z*z);
    m[1][2] = 2 * (y*z + x*w);
    m[2][0] = 2 * (x*z + y*w);
    m[2][1] = 2 * (y*z - x*w);
    m[2][2] = 1 - 2 * (x*x + y*y);
    
    return m;
}

mat4 getTranslationMat(vec3 pos) {
    mat4 m = mat4(1);
    m[3][0] = pos.x;
    m[3][1] = pos.y;
    m[3][2] = pos.z;
    return m;
}

mat4 applyTransformation(vec3 pos, vec4 rot, vec3 scale) {
    mat4 transMat = getTranslationMat(pos);
    mat4 rotMat = mat4(quatToMat(rot));
    mat4 scaleMat = mat4(mat3(scale));
    return transMat * rotMat * scaleMat;
}

layout (local_size_x=1, local_size_y=1, local_size_z=1) in;

uniform float timeSinceApplicationStarted;

void main() {

}